# 언어 관련 공통 질문
## Q. Call By Value와 Call By Reference 차이
함수를 호출할 때 매개변수로 전달되는 값의 종류에 따라 call by value, call by reference로 나뉩니다. value는 원본 값을 그대로 복사하므로, caller 함수에서의 변화가 원본에 영향을 미칠 수 없습니다. 반면에 reference는 원본의 주소값을 복사하여 전달하므로, caller 함수에서 원본에 영향을 줄 수 있습니다.

### 꼬리질문 1. 왜 원본 값을 그대로 복사하면 원본에 영향을 줄 수 없고, 주소값을 복사하면 원본에 영향을 줄 수 있는가?
매개변수는 함수를 호출하면 새로운 스택 메모리에 할당됩니다. 따라서 원본과는 전혀 다른 메모리 공간에 할당되는 다른 지역변수로 동작합니다. 만약 매개변수에 원본의 value를 가지고 있다면, 원본과는 전혀 관계가 없는 단순히 원본 값을 가지고 있는 변수일 뿐입니다. 하지만 매개변수에 원본의 주소값을 가지고 있다면, 이는 원본에 접근을 할 수 있게 됩니다.

### 꼬리질문 2. Java는 call by value인가? call by reference인가? 아니면 둘 다 가능한가?
Java는 call by value만 가능하다고 생각합니다. 이는 원본에 대한 제 생각때문입니다. 원본은 선언된 자료형에 따라 할당된 값입니다. 특히 변수에 객체를 선언하면 그 변수는 객체의 시작 주소값을 갖고 있습니다. 원본이 변경된다는 것은 이 할당된 객체의 주소값이 변경되는 것이지, 객체 내부의 다른 데이터가 변경되는 것은 아니라고 생각합니다. 이를 바탕으로 보면 Java는 call by reference를 할 수 없습니다. 왜냐하면 원본의 주소를 추출하고 저장할 자료형을 제공하지 않기 때문입니다. 반면에 C++는 포인터를 통해 주소를 추출하고 저장할 수 있기 때문에 call by reference가 가능합니다.

### Reference
- [Call By Value VS Call By Reference](https://velog.io/@codemcd/Call-By-Value-VS-Call-By-Reference)

## Q. 얕은 복사(Shallow Copy) VS 깊은 복사(Deep Copy)
얕은 복사는 단순히 지정된 값만 복사하는 것이고, 깊은 복사는 지정된 값이 주소값인 경우, 이를 참조하고 있는 모든 값을 복사하는 것입니다.

### 꼬리질문 1. 깊은 복사를 하는 이유는 무엇인가요?(얕은 복사의 문제점은 무엇인가요?)
얕은 복사를 하게 되는 경우 복사하는 값이 주소값인 경우 참조하는 데이터를 원본과 복사본이 공유하게 됩니다. 따라서 복사본에서 참조한 데이터를 수정하면, 원본도 같이 수정되어 의도하지 않는 변경이 발생할 수 있습니다. 이를 해결하기 위해 깊은 복사로 참조된 데이터까지 모두 복사하여, 원본 데이터와 완전히 분리할 수 있습니다.

### 꼬리질문 1-1. 얕은 복사의 문제점 중 실제 어떤 예가 있을까요?
C++에서는 복사 생성자로 객체를 얕은 복사를 하는 경우, 삭제 시 문제가 발생합니다. 왜냐하면 원본과 복사본이 같은 데이터를 가리키고 있는데, 둘 중 하나가 먼저 해제되면, 그 다음에 해제될 데이터가 사라지기 때문입니다.

Java에서는 객체 내부의 멤버 변수로 `LinkedList`와 같은 컬렉션이 있을 때 외부에서 단순히 =으로 복사하는 경우, 외부에서 이 컬렉션의 데이터를 변경하면, 객체 내부 멤버 변수도 같이 변경되는 문제가 발생합니다.

## Q. 기본 자료형(primitive data type)과 참조 자료형(reference data type)에 대해 설명하시오.